---
/**
 * GlobeMap - Interactive 3D globe showing SharkTrack usage locations.
 *
 * Uses the `cobe` library (lightweight WebGL globe).
 * Each location appears as a marker on the globe. Clicking a location chip
 * rotates the globe to that position and shows project details in a side panel.
 *
 * Props:
 *   - locations: Array of location objects. Falls back to built-in defaults.
 *
 * To add a new location, add an entry to the `defaultLocations` array below,
 * or pass a `locations` prop from the MDX page.
 */
import defaultLocations from "../../assets/sharktrack/example_usages/usages.json";

interface Location {
  name: string;
  lat: number;
  lng: number;
  description: string;
  link?: string;
  image?: string;
}

interface Props {
  locations?: Location[];
}

const typedDefaultLocations = defaultLocations as Location[];

const { locations = typedDefaultLocations } = Astro.props;
---

<section class="globe-section" id="users-worldwide">
  <h2 class="globe-section__title">Users Worldwide</h2>
  <p class="globe-section__subtitle">
    Used by <strong>{locations.length}</strong> research groups across the globe
  </p>

  <div class="globe-section__layout">
    <div class="globe-section__canvas-wrap">
      <canvas id="cobe-globe"></canvas>
    </div>
    <div class="globe-section__panel" id="globe-info-panel">
      <p class="globe-section__panel-hint">Click a location to explore</p>
    </div>
  </div>

  <div class="globe-section__chips" id="location-chips">
    {locations.map((loc) => (
      <button
        class="location-chip"
        data-lat={loc.lat}
        data-lng={loc.lng}
        data-name={loc.name}
        data-description={loc.description}
        data-link={loc.link || ""}
        data-image={loc.image || ""}
      >
        <span class="location-chip__dot" />
        {loc.name}
      </button>
    ))}
  </div>
</section>

<script>
  import createGlobe from "cobe";

  const canvas = document.getElementById("cobe-globe") as HTMLCanvasElement;

  if (canvas) {
    const TWO_PI = Math.PI * 2;

    let currentPhi = 0;
    let currentTheta = 0.25;
    let focusPhi = 0;
    let focusTheta = 0.25;
    let isFocused = false;
    let width = 0;
    let focusTimeout: ReturnType<typeof setTimeout> | null = null;
    let activeMarkerIndex = -1;

    const chips = document.querySelectorAll(".location-chip");
    const infoPanel = document.getElementById("globe-info-panel");

    // Convert lat/lng to cobe's phi/theta coordinate system
    function locationToAngles(lat: number, lng: number): [number, number] {
      return [
        Math.PI - ((lng * Math.PI) / 180 - Math.PI / 2),
        (lat * Math.PI) / 180,
      ];
    }

    // Pre-compute location data from chip attributes
    const locationData = Array.from(chips).map((btn) => ({
      lat: parseFloat(btn.getAttribute("data-lat") || "0"),
      lng: parseFloat(btn.getAttribute("data-lng") || "0"),
    }));

    // Build marker array; the active marker gets a larger size
    function buildMarkers() {
      return locationData.map((loc, i) => ({
        location: [loc.lat, loc.lng] as [number, number],
        size: i === activeMarkerIndex ? 0.15 : 0.07,
      }));
    }

    // Handle responsive sizing
    const onResize = () => {
      if (canvas.parentElement) {
        width = canvas.parentElement.offsetWidth;
      }
    };
    window.addEventListener("resize", onResize);
    onResize();

    // Also observe layout changes (e.g. when info panel content changes the
    // flex layout, the canvas wrapper may resize without a window resize event)
    if (canvas.parentElement && typeof ResizeObserver !== "undefined") {
      new ResizeObserver(onResize).observe(canvas.parentElement);
    }

    // Ensure we have a usable width even if the parent hasn't been laid out yet
    if (width === 0) width = 400;

    // Shared onRender callback used across globe instances
    function onRender(state: Record<string, number>) {
      if (!isFocused) {
        currentPhi += 0.005;
      } else {
        // Shortest-path interpolation: wrap the difference to [-Ï€, Ï€]
        // so the globe always takes the shortest rotation to the target
        const diff =
          ((focusPhi - currentPhi) % TWO_PI + 3 * Math.PI) % TWO_PI -
          Math.PI;
        currentPhi += diff * 0.08;
        currentTheta += (focusTheta - currentTheta) * 0.08;
      }

      state.phi = currentPhi;
      state.theta = currentTheta;
      state.width = width * 2;
      state.height = width * 2;
    }

    // Create (or recreate) the globe, preserving the current rotation
    function createGlobeInstance() {
      return createGlobe(canvas, {
        devicePixelRatio: 2,
        width: width * 2,
        height: width * 2,
        phi: currentPhi,
        theta: currentTheta,
        dark: 1,
        diffuse: 3,
        mapSamples: 20000,
        mapBrightness: 6,
        baseColor: [0.05, 0.2, 0.4],
        markerColor: [0.1, 0.8, 1.0],
        glowColor: [0.05, 0.15, 0.3],
        markers: buildMarkers(),
        onRender,
      });
    }

    // Initialize cobe globe
    let globe = createGlobeInstance();

    // Handle location chip clicks
    chips.forEach((btn, index) => {
      btn.addEventListener("click", () => {
        const { lat, lng } = locationData[index];
        const name = btn.getAttribute("data-name") || "";
        const description = btn.getAttribute("data-description") || "";
        const link = btn.getAttribute("data-link") || "";
        const image = btn.getAttribute("data-image") || "";

        // Rotate globe to location
        const [p, t] = locationToAngles(lat, lng);
        focusPhi = p;
        focusTheta = t;
        isFocused = true;

        // Highlight the active marker by recreating the globe with
        // an enlarged pin at this location (cobe bakes markers at init)
        activeMarkerIndex = index;
        globe.destroy();
        globe = createGlobeInstance();

        // Update active chip
        chips.forEach((b) => b.classList.remove("active"));
        btn.classList.add("active");

        // Update info panel
        if (infoPanel) {
          let html = `<div class="globe-info-card">
            <h3>${name}</h3>
            <p>${description}</p>`;
          if (image) {
            html += `<img src="${image}" alt="${name}" class="globe-info-card__image" />`;
          } else {
            html += `<div class="globe-info-card__image-placeholder">ðŸ“· Images coming soon...</div>`;
          }
          if (link) {
            html += `<a href="${link}" target="_blank" rel="noopener noreferrer" class="globe-info-card__link">Learn more â†’</a>`;
          }
          html += `</div>`;
          infoPanel.innerHTML = html;
        }

        // Clear any previous timeout to prevent early auto-rotation resume
        if (focusTimeout) clearTimeout(focusTimeout);

        // Resume auto-rotation after 4 seconds
        focusTimeout = setTimeout(() => {
          isFocused = false;
        }, 4000);
      });
    });

    // Cleanup on page navigation (Astro View Transitions)
    document.addEventListener("astro:before-swap", () => {
      globe.destroy();
    });
  }
</script>
